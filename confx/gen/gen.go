package main

import (
	"bytes"
	"errors"
	"fmt"
	"go/ast"
	gobuild "go/build"
	"go/format"
	goparser "go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	run()
}

func run() error {
	dir, err := getImportPkg("github.com/spf13/viper")
	if err != nil {
		return fmt.Errorf(err.Error())
	}
	log.Printf("dir: %+v", dir)

	pkg, err := parseDir(dir, "viper")
	if err != nil {
		return fmt.Errorf(err.Error())
	}
	funcs, setFuncs, err := walkAst(pkg)
	if err != nil {
		return fmt.Errorf(err.Error())
	}
	fmt.Println("setFuncs", setFuncs)
	//fmt.Println(getFuncs)
	saveDir, _ := os.Getwd()
	saveDir = filepath.Dir(saveDir)
	f := filepath.Join(saveDir, "viper.go")
	ff, err := os.OpenFile(f, os.O_WRONLY|os.O_CREATE, 0664)
	if err != nil {
		return fmt.Errorf(err.Error())
	}
	defer ff.Close()
	_ = buildSource(os.Stdout, funcs)
	return buildSource(ff, funcs)
}

func walkAst(node ast.Node) ([]ast.Decl, []ast.Decl, error) {
	v := &visitor{}
	ast.Walk(v, node)

	log.Printf("getFuncs len: %d", len(v.getFuncs))

	var decls, setDecls []ast.Decl
	for _, v := range v.getFuncs {
		decls = append(decls, v)
	}
	for _, v := range v.setFuncs {
		setDecls = append(setDecls, v)
	}

	return decls, setDecls, nil
}

func parseDir(dir, pkgName string) (*ast.Package, error) {
	pkgMap, err := goparser.ParseDir(
		token.NewFileSet(),
		dir,
		func(info os.FileInfo) bool {
			// skip go-test
			return !strings.Contains(info.Name(), "_test.go")
		},
		goparser.Mode(0), // no comment
	)
	if err != nil {
		return nil, fmt.Errorf(err.Error())
	}

	pkg, ok := pkgMap[pkgName]
	if !ok {
		err := errors.New("not found")
		return nil, fmt.Errorf(err.Error())
	}

	return pkg, nil
}
func getImportPkg(pkg string) (string, error) {
	p, err := gobuild.Import(pkg, "", gobuild.FindOnly)
	if err != nil {
		return "", err
	}

	return p.Dir, err

}

type visitor struct {
	getFuncs []*ast.FuncDecl
	setFuncs []*ast.FuncDecl
}

func (v *visitor) Visit(node ast.Node) ast.Visitor {
	switch n := node.(type) {
	case *ast.FuncDecl:
		//fmt.Println(n.Name.String())
		if n.Recv == nil ||
			!n.Name.IsExported() ||
			len(n.Recv.List) != 1 {
			return nil
		}
		//t, ok := n.Recv.List[0].Type.(*ast.StarExpr)
		//if ok {
		//	return nil
		//}
		//_ = t

		//fmt.Println(n.Body)
		name := n.Name.String()
		if !strings.HasPrefix(name, "Get") && !strings.HasPrefix(name, "Set") {
			return nil
		}
		fmt.Println(name)
		//fmt.Printf("%#v\n", n.Body.List)
		//if t.X.(*ast.Ident).String() != "SugaredLogger" {
		//	return nil
		//}
		if len(n.Body.List) == 0 {
			return nil
		}
		if _, ok := n.Body.List[0].(*ast.ReturnStmt); ok && strings.HasPrefix(name, "Get") {
			log.Printf("func name: %s", n.Name.String())
			v.getFuncs = append(v.getFuncs, rewriteFunc(n))
			return nil
		}
		_, ok := n.Recv.List[0].Type.(*ast.StarExpr)
		if !ok && strings.HasPrefix(name, "Set") {
			v.setFuncs = append(v.setFuncs, rewriteFunc(n))
		}
		return nil

	}
	return v
}
func rewriteSetFunc(fn *ast.FuncDecl) *ast.FuncDecl {
	return nil
}
func rewriteFunc(fn *ast.FuncDecl) *ast.FuncDecl {
	fn.Recv = nil

	fnName := fn.Name.String()

	var args []string
	for _, field := range fn.Type.Params.List {
		for _, id := range field.Names {
			idStr := id.String()
			_, ok := field.Type.(*ast.Ellipsis)
			if ok {
				// Ellipsis args
				idStr += "..."
			}
			args = append(args, idStr)
		}
	}

	exprStr := fmt.Sprintf(`viper.%s(%s)`, fnName, strings.Join(args, ","))
	expr, err := goparser.ParseExpr(exprStr)
	if err != nil {
		panic(err)
	}

	var body []ast.Stmt
	if fn.Type.Results != nil {
		body = []ast.Stmt{
			&ast.ReturnStmt{
				// Return:
				Results: []ast.Expr{expr},
			},
		}
	} else {
		body = []ast.Stmt{
			&ast.ExprStmt{
				X: expr,
			},
		}
	}

	fn.Body.List = body

	return fn
}

func astToGo(dst *bytes.Buffer, node interface{}) error {
	addNewline := func() {
		err := dst.WriteByte('\n') // add newline
		if err != nil {
			log.Panicln(err)
		}
	}

	addNewline()

	err := format.Node(dst, token.NewFileSet(), node)
	if err != nil {
		return err
	}

	addNewline()

	return nil
}

func buildSource(wr io.Writer, funcs []ast.Decl) error {
	header := `// Code generated by confx-gen. DO NOT EDIT.
package confx

import (
	"time"

	"github.com/spf13/viper"
)

func Get(key string) interface{} { return viper.Get(key) }

func SetDefault(key string, value interface{}) { viper.SetDefault(key, value) }
`
	buffer := bytes.NewBufferString(header)

	for _, fn := range funcs {
		err := astToGo(buffer, fn)
		if err != nil {
			return fmt.Errorf(err.Error())
		}
	}
	source, err := format.Source(buffer.Bytes())
	if err != nil {
		return err
	}

	_, err = wr.Write(source)
	return err
}
